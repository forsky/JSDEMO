<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>
            浏览器环境概述:代码嵌入网页的方法
        </title>
    </head>
    <body>
        代码嵌入网页的方法：script 元素直接嵌入代码；
        script 加载外部脚本；
        事件属性
        URL协议；

        script 元素嵌入代码 type 属性可以设置为两种值；
        type/javascript  默认值，老式浏览器设置这个值好；
        application/javascript 对于比较新的浏览器，建议设置为这个值；
        如果type属性的值，浏览器不认识，那么它不会执行其中的代码；

        script 元素加载外部脚本
        “script src="www.examle.com/script.js"  script”
        如果脚本使用了非英语字符，要注明字符的编码；
        script charset="utf-8" src="www.examle.com/script.js"
        所加载的js代码必须是纯的  不能有html和script;
        防止攻击者篡改外部脚本，script标签允许设置一个intergrity属性，写入该外部脚本的Hash签名，用来验证脚本的一致性；
        script src="/assets/application.js"
         integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
        script
        
        事件属性；

        URL协议；

        defer 属性
        为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对script元素加入defer属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。

        解决“阻塞效应”的另一个方法是对script元素加入async属性。
        async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染

        一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。

        脚本的动态加载 
        无法保证脚本的执行顺序，那个脚本先下载完，就先执行哪个；

        script src="example.js" script      默认HTTP协议下载；
        script src="https://example.js" script  HTTPS协议下载；
        script src="//example.js" script   页面本身的协议来决定加载协议；

        Firefox：Gecko 引擎
        Safari：WebKit 引擎
        Chrome：Blink 引擎
        IE: Trident 引擎
        Edge: EdgeHTML 引擎

        解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
        对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
        布局：计算出渲染树的布局（layout）。
        绘制：将渲染树绘制到屏幕。

        





    </body>
</html>